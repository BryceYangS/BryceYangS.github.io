---
layout: post
title: "[JPA] N+1 문제"
subtitle: "N+1"
categories: study
tags: jpa
---

> N + 1 문제와 해결 방법


## N + 1 문제
- 쿼리가 N + 1번 발생하는 문제
- Eager / Lazy 모두 발생함
  - Eager : JPA에서는 문제 없으나 JPQL을 이용할 시 문제 발생.
    - JPQL은 쿼리에 대한 분석만 이뤄지기 때문에 fetch type과는 상관없이 쿼리 발생
  - Lazy : 프록시 객체로 가지고 있던 객체가 실제 사용될 때 쿼리가 발생함
    - 엔티티 내부 컴포지션으로 갖고 있던 해당 객체에 접근할 때마다 쿼리 발생

![uml](/assets/img/jpa/n_1.png)

### Team 클래스
```java
@Entity
@Getter
@Setter
public class Team {
	@Id
	@GeneratedValue
	@Column(name = "team_id")
	private Long id;

	private String name;

	@OneToMany(mappedBy = "team")
	private List<TestMember> testMembers = new ArrayList<>();
}
```

### Member 클래스
```java
@Entity
@Getter
@Setter
public class TestMember {

	@Id
	@GeneratedValue
	@Column(name = "member_id")
	private Long id;

	private String name;

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "team_id")
	private Team team;

}
```

### N + 1 발생 테스트 코드
```java
@Test
	public void N플러스1_테스트() throws Exception {
		// given
		Team teamA = new Team();
		teamA.setName("팀A");
		em.persist(teamA);

		Team teamB = new Team();
		teamB.setName("팀B");
		em.persist(teamB);

		TestMember testMember1 = new TestMember();
		testMember1.setName("회원1");
		testMember1.setTeam(teamA);
		em.persist(testMember1);

		TestMember testMember2 = new TestMember();
		testMember2.setName("회원2");
		testMember2.setTeam(teamA);
		em.persist(testMember2);

		TestMember testMember3 = new TestMember();
		testMember3.setName("회원3");
		testMember3.setTeam(teamB);
		em.persist(testMember3);

		em.flush();
		em.clear();

		// when
		String query = "select m from TestMember m";
		List<TestMember> resultList = em.createQuery(query, TestMember.class).getResultList();

		for (TestMember member : resultList) {
			System.out.println("member = " + member.getName() + ", " + member.getTeam().getName());
		}

		// then
		assertThat(resultList.size()).isEqualTo(3);
	}
```

### N + 1 발생 로그  
- 처음에 TestMember를 조회하는 쿼리 - 1회
- TestMember 조회 결과 반복문을 돌면서 Team 정보 조회 - 2회
  - 왜 3회가 아니라 2회? 기존 팀A 엔티티가 영속성 컨텍스트에 `1차 캐싱`되었기 때문

```log
Hibernate: 
    select
        testmember0_.member_id as member_i1_8_,
        testmember0_.name as name2_8_,
        testmember0_.team_id as team_id3_8_ 
    from
        test_member testmember0_

Hibernate: 
    select
        team0_.team_id as team_id1_7_0_,
        team0_.name as name2_7_0_ 
    from
        team team0_ 
    where
        team0_.team_id=?
member = 회원1, 팀A
member = 회원2, 팀A

Hibernate: 
    select
        team0_.team_id as team_id1_7_0_,
        team0_.name as name2_7_0_ 
    from
        team team0_ 
    where
        team0_.team_id=?
member = 회원3, 팀B
```

## 해결 방법

### Fetch Join
- 대부분의 N + 1 문제는 `Fetch Join`으로 해결
- fetch join을 사용하면 프록시가 아닌 `실제 엔티티`가 담김. 영속성 컨텍스트에 올라가 있는 객체.
- 일반 조인과 차이점
  - 일반 조인 실행 시 연관된 엔티티를 함께 조회하지 않음. 조인만 해줌. select 절에 연관 엔티티 정보가 포함 되지 않음
  - JPQL은 결과를 반환할 때 연관관계 고려 ❌
  - 단지 SELECT 절에 지정한 엔티티만 조회
  - 페치 조인을 사용할 때만 연관된 엔티티 조회 **(사실상 즉시로딩)**
  - *페치 조인은 객체 그래프를 SQL 한번에 조회하는 개념*

```java
	@Test
	public void N플러스1_테스트() throws Exception {
    
    // ... 상단은 동일하기 때문에 생략합니다.

		String query = "select m from TestMember m join fetch m.team";
		List<TestMember> resultList = em.createQuery(query, TestMember.class).getResultList();

		for (TestMember member : resultList) {
			System.out.println("member = " + member.getName() + ", " + member.getTeam().getName());
		}

    // ... 하단 생략
  }
```

```log
Hibernate: 
    select
        testmember0_.member_id as member_i1_8_0_,
        team1_.team_id as team_id1_7_1_,
        testmember0_.name as name2_8_0_,
        testmember0_.team_id as team_id3_8_0_,
        team1_.name as name2_7_1_ 
    from
        test_member testmember0_ 
    inner join
        team team1_ 
            on testmember0_.team_id=team1_.team_id
member = 회원1, 팀A
member = 회원2, 팀A
member = 회원3, 팀B
```

## 참조
- 김영한님의 인프런 강의 : [자바 ORM 표준 JPA 프로그래밍 - 기본편](https://www.inflearn.com/course/ORM-JPA-Basic/dashboard)