---
layout: post
title: "[Book] Clean Architecture"
subtitle: "clean architecture"
categories: various
tags: techBook
---
> 로버트 C.마틴의 \<Clean Architecture\> 정리

# Clean Architecture
  - 로버트 C.마틴 지음

## 1부. 소개
### 1장. 설계와 아키텍처란?
설계와 아키텍처 사이에는 차이가 없다.  

> 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.  

### 2장. 두 가지 가치에 대한 이야기
모든 소프트웨어 시스템은 이해관계자에게 서로 다른 두 가지 가치를 제공하는데, **행위**와 **구조**가 바로 그것이다.

#### 행위

---

프로그래머는 이해관계자가 기능 명세서나 요구사항 문서를 구체화할 수 있도록 돕는다. 그리고 이해관계자의 기계가 이러한 요구사항을 만족하도록 코드를 작성한다. 하지만 이러한 활동이 프로그래머가 해야 할 일의 전부는 아니다.

#### 아키텍처

---

소프트웨어는 *부드러움을 지니도록* 만들어졌다.**소프트웨어를 만든 이유는 기계의 행위를 쉽게 변경할 수 있도록 하기 위해서다.**

아키텍처가 특정 형태를 다른 형태보다 선호하면 할수록, 새로운 기능을 이 구조에 맞추는게 더 힘들어진다. 따라서 아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다.

#### 아이젠하워 매트릭스

---

|        | 긴급 O                    | 긴급 X                           |
| ------ | ------------------------- | -------------------------------- |
| 중요 O | 중요함<br />긴급함        | 중요함<br />긴급하지 않음        |
| 중요 X | 중요하지 않음<br />긴급함 | 중요하지 않음<br />긴급하지 않음 |

기능의 긴급성이 아닌 아키텍처의 중요성을 설득하는 일은 소프트웨어 개발팀이 마땅히 책임져야 한다.

**아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다.** 이러한 상황이 발생하도록 용납했다면, 소프트웨어 개발팀이 스스로 옳다고 믿는 가치를 위해 충분히 투쟁하지 않았다는 뜻이다.



## 2부. 벽돌부터 시작하기 : 프로그래밍 패러다임

**구조적 프로그래밍** : 제어흐름의 직접적인 전환에 대한 규칙을 부과

**객체 지향 프로그래밍** : 제어흐름의 간접적인 전환에 대한 규칙을 부과

**함수형 프로그래밍** : 할당문에 대한 규칙을 부과

*패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.*



### 4장. 구조적 프로그래밍

모든 프로그램을 순차, 분기, 반복이라는 세 가지 구조만으로 표현할 수 있다는 사실이 증명됐다. → 모듈을 증명 가능하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다.

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 됐고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다. 이 기법을 사용하면 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있다.

구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다. 그러고 나서 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다. 이처럼 거짓임을 증명하려는 테스트가 실패한다면, 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여기게 된다.



### 5장. 객체지향 프로그래밍

객체지향? 

- "데이터와 함수의 조합", "실제 세계를 모델링하는 새로운 방법" : 모두 애매모호한 정의
- 캡슐화, 상속, 다형성

#### 1. 캡슐화

데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 객체지향 언어가 제공. 캡슐화를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분짓는 선을 그을 수 있음.

하지만, C 언어에서도 캡슐화 구현 가능. 클래스 선언과 정의를 구분하는 게 아예 불가능한 자바, C#에서 오히려 캡슐화가 더 심하게 훼손됨.

*객체지향이 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘듦*

객체지향 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 함.

#### 2. 상속

상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과.

객체지향 언어가 완전히 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼 수 있음

#### 3. 다형성

C언어를 통해서 구현 가능. 함수를 가리키는 포인터를 응용한 것이 다형성.

객체지향 언어가 다형성을 새롭게 만든 것이 아니지만, 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해준다.

**객체지향 언어는 제어흐름을 간접적으로 전환하는 규칙을 부과한다**

#### 의존성 역전

다형성을 안전하고 편리하게 적용할 수 있는 메커니즘이 등장하기 전 소프트웨어는 min 함수가 고수준 함수를 호출하고, 고수준 함수가 다시 중간 수준 함수를 호출하며, 중간 수준 함수는 다시 저수준 함수를 호출한다. 이러한 호출 트리에서 소스 코드 의존성의 방향은 반드시 `제어흐름(flow of control)`을 따르게 된다. *제어 흐름은 시스템의 행위에 따라 결정되며, 소스코드 의존성은 제어흐름에 따라 결정된다.*

다형성을 통해, 소스 코드 의존성(상속관계)이 제어흐름과는 반대가 된다. 이를 **의존성 역전**이라고 부른다. 객체지향 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 *소스코드 의존성을 어디에서든 역전시킬 수 있다*는 뜻이다. 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한하지 않는다. 호출하는 모듈이든 호출 받는 모듈이든 관계없이 소프트웨어 아키텍트는 소스 코드 의존성을 원하는 방향으로 설정할 수 있다.

#### 결론

소프트웨어 아키텍트 관점에서 `객체지향`이란 ***다형성을 이용해 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력***. 

의존성 역전을 통해 모듈의 독립성 확보 → 배포 독립성, 개발 독립성 확보



### 6장. 함수형 프로그래밍

자바 프로그램은 가변 변수를 사용. 가변변수는 프로그램 실행 중에 상태가 변할 수 있다. 이와 달리 *함수형 언어에서 변수는 변경되지 않는다.*

#### 불변성과 아키텍처

변수의 가변성이 중요한 이유? 경합 조건, 교착상태 조건, 동시 업데이트 문제 모두 가변 변수로 인해 발생하기 때문. 동시성 애플리케이션에서 마주치는 모든 문제, 즉 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.

가변 컴포넌트와 불변 컴포넌트를 분리를 통해 불변성을 구현한다. 애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 한다.

현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.

#### 이벤트 소싱

이벤트 소싱은 상태가 아닌 **트랜잭션**을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다. 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다. 애플리케이션은 CRUD가 아니라 그저 CR만 수행. 데이터 저장소에서 변경과 삭제가 전혀 발생하지 않으므로 동시 업데이트 문제 또한 일어나지 않는다.

 저장공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고, 따라서 완전한 함수형으로 만들 수 있음.

eg. 소스 코드 버전 관리 시스템

> 각 패러다임은 우리가 코드를 작성하는 방식의 형태를 한정시킴.
>
> 소프트웨어, 즉 컴퓨터 프로그램은 순차, 분기, 반복, 참조로 구성된다. 그 이상도 이하도 아니다.



## 3부. 설계 원칙

**SOLID 원칙**

- 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해주는 원칙.
- 객체 지향 소프트웨어에만 적용 ❌. '클래스'는 단순히 함수와 데이터를 결합한 집합을 의미.
- 목적
  - 변경에 유연
  - 이해하기 쉽다
  - 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기준이 된다

### 7장. SRP : 단일 책임 원칙

> 단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.

단 하나의 일만 해야 한다는 원칙은 따로 있으니 헷갈리지 말 것!

***하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다***

서로 다른 액터가 의존하는 코드를 서로 분리하라!

단일 책임 원칙은 메서드와 클래스 수준의 원칙. 

### 8장. OCP : 개방-폐쇄 원칙

> 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다. 컴포넌트 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

추이 종속성을 가지게 되면, 소프트웨어 엔티티는 '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다'는 소프트웨어 원칙을 위반하게 된다. 추이 종속성은 인터페이스를 활용한 정보 은닉 달성을 통해 해결할 수 있다.

**OCP의 목표**

- 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있음
- 이러한 목표 달성을 위해 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.

🙋🏻추이 종속성*

클래스 A가 클래스 B에 의존하고, 다시 클래스 B가 클래스 C에 의존한다면, 클래스 A는 클래스 C에 의존하게 된다. 이를 추이 종속성이라고 부르며, 클래스 이외의 소프트웨어의 모든 엔티티(패키지, 컴포넌트 등)에도 동일하게 적용됨.

### 9장. LSP : 리스코프 치환 원칙

> S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.

초창기 LSP는 상속을 사용하도록 가이드하는 방법 정도로 간주됨. 하지만 LSP는 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모.

### 10장. ISP : 인터페이스 분리 원칙

> 범용적인 인터페이스보다 여러 인터페이스로 분리하는 것이 낫다

### 11장. DIP

> 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는다

자바와 같은 정적 타입 언어에서 이 말은 use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻으로, **구체적인 대상에는 절대로 의존해서는 안 된다.** 안정적이고 변경이 자주 일어나지 않으리라 확신할 수 있는 것에 대한 의존은 무시한다. 의존하지 않도록 피하고자 하는 것은 *변동성이 큰* 구체적인 요소이다.

인터페이스는 구현체보다 변동성이 낮다. 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처이다.

- 변동성이 큰 구체 클래스를 참조하지 말라. 대신 추상 인터페이스를 참조하라.
  - 객체 생성 방식을 강하게 제약하며, 일반적으로 *추상 팩토리*를사용하도록 강제한다.
- 변동성이 큰 구체 클래스로부터 파생하지 말라.
  - 상속은 소스 코드에 존재하는 모든 관계 중 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다. 따라서 *상속은 아주 신중하게 사용*
- 구체 함수를 오버라이드 하지 말라.
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라 (DIP 원칙)

⭐️**의존성 역전**

소스 코드 의존성은 제어흐름과는 반대 방향으로 역전

## 4부. 컴포넌트 원칙

SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법. 컴포넌트 원칙은 빌딩에 방을 배치하는 방법.

### 12장. 컴포넌트

컴포넌트?

- 배포 단위. 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위.

- eg. 자바 : jar 파일이 컴포넌트.
- 잘 설계된 컴포넌트는 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다.

### 13장. 컴포넌트 응집도

어느 클래스들을 묶어서 컴포넌트로 만들지를 결정할 때, `재사용성`과 `개발가능성`이라는 상충하는 힘을 반드시 고려.

어떤 클래스를 어떤 컴포넌트에 포함시켜야 하는지에 대한 원칙 3가지.

#### 1. REP : 재사용/릴리스 등가 원칙

> 재사용 단위는 릴리스 단위와 같다

단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 한다. 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.

하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다.

#### 2. CCP : 공통 폐쇄 원칙

> 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라.
>
> 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

단일 책임 원칙을 컴포넌트 관점에서 다시 쓴 것. 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다는 의미.

**SRP와의 유사성**

CCP는 컴포넌트 수준의 SRP.

- SRP : 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리하라

- CCP : 서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리하라

#### 3. CRP : 공통 재사용 원칙

> 컴포넌트 사용자들을 필요하지 않은 것에 의존하게 강요하지 말라

클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움이 되는 원칙.

*같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다.*

CRP는 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다고 말한다.

**ISP와의 관계**

CRP는 인터페이스 분리 원칙의 포괄적인 버전.

- ISP : 사용하지 않은 메서드가 있는 클래스에 의존하지 말라
- CRP : 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라

### 14장. 컴포넌트 결합

컴포넌트 사이의 관계

#### ADP : 의존성 비순환 원칙

> 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다

구성요소 간 의존성을 파악하고 있으면 시스템을 빌드하는 방법을 알 수 있다. 시스템 전체를 릴리스해야 할 때가 오면 릴리스 절차는 *상향식*으로 진행된다. (Entities → Database, Interactors → Presenters, View → Main).

순환이 생기면 컴포넌트를 분리하기 어려워진다. 또한, 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어진다.

**순환 의존 해결법 2가지**

1. DIP 적용
2. 새로운 컴포넌트 생성

컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없음. 오히려 컴포넌트 의존성 다이어그램은 애플리케이션의 `빌드가능성`과 `유지보수성`을 보여주는 지도와 같다. → 이에, 컴포넌트 구조는 프로젝트 초기에 설계할 수 없음.



애플리케이션이 계속 성장함에 따라 우리는 재사용 가능한 요소를 만드는 일에 관심을 기울이기 시작. 이 시점이 되면 컴포넌트를 조합하는 과정에 공통 재사용 원칙(CRP)이 영향을 미치기 시작. 결국 순환이 발생하면 ADP가 적용됨. 컴포넌트 의존성 그래프는 조금씩 흐트러지고 또 성장한다.

❗️클래스 설계가 되지도 않은 상태에서 컴포넌트 의존성 구조를 설계하려고 시도하면 실패할 수 있음.

#### SDP : 안정된 의존성 원칙

> 더 안정된 쪽에 의존하라

#### SAP : 안정된 추상화 원칙

> 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.

안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안 된다. 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다. 컴포넌트가 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다.

## 5부. 아키텍처

### 15장. 아키텍처란?

### 16장. 독립성

### 17장. 경계 : 선 긋기

### 18장. 경계 해부학

### 19장. 정책과 수준

### 20장. 업무 규칙

### 21장. 소리치는 아키텍처

### 22장. 클린 아키텍처

### 23장. 프레젠터와 험블 객체

### 24장. 부분적 경계

### 25장. 계층과 경계

### 26장. Main 컴포넌트

### 27장. '크고 작은 모든' 서비스들

### 28장. 테스트 경계

### 29장. 클린 임베디드 아키텍처

## 6부. 세부사항