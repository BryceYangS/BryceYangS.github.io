---
layout: post
title: "[데이터 중심 애플리케이션 설계] 4장. 부호화와 발전"
subtitle: "데이터 중심 애플리케이션 설계, 4장, 부호화와 발전"
categories: various
tags: techBook
---
> 4장. 부호화와 발전

4장의 핵심 내용  
- 인코등 다양한 형식
- 메시지 전달 시스템과 데이터 인코딩 형식 -> 데이터 저장 및 통신에서의 사용 방법

**상위 호환성** : 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야.  
**하위 호환성** : 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야.  

# 1. 데이터 부호화 형식
**부호화**(직렬화) : 인메모리 표현 -> 바이트열  
**복호화**(파싱, 역직렬화) : 바이트열 -> 인메모리 표현  

## 1.1 언어별 형식
각 언어 별 직렬화 기능 내장되어 있음. 

- 언어 내장 부호화 라이브러리 문제점
  - 특정 언어와 강결합 : 다른 언어와의 통합 시 어려움 존재
  - 보안 : 바이트 복호화 시 보안 관련 문제 발생 가능성 존재
  - 상, 하위 호환성 떨어짐
  - 효율성 : 성능 떨어지는 경우 많음.


## 1.2 JSON, XML, 이진변형
### JSON
- 문자열, 수 구분.
- 정수, 부동소수점 수 구별 X, 정밀도 지정 불가
- 2^53 보다 큰 정수 부정확해질 가능성 존재
- 유니코드 문자열 지원. 이진 문자열 지원 X
- 스키마 지원

### XML
- 복잡한 형식
- 수, 숫자(digit) 문자열 구분 불가
- 유니코드 지원. 이진 문자열 지원 X.
- 스키마 지원

### CSV
- 수, 숫자(digit) 문자열 구분 불가
- 스키마 X
- 모호한 형식 : 값이 쉼표, 개행문자 포함 경우 난감;;


### 이진 부호화
JSON과 XML은 간단. 허나 공간에 있어 이진 형식보다 큼. 이진 부호화가 크기, 파싱 속도에 있어 효율적. but, 가독성과 크기 간의 트레이드 오프는 고민 지점.

#### 스리프트 & 프로토콜 버퍼
> 이진 부호화 라이브러리
> 스리프트, 프로토콜 버퍼 모두 스키마 필요.
> 기존 이진 부호화와 달리 `필드 태그` 존재
> 스키마의 required, optional 정보에 대한 부호화 X. 실행 때 확인

- 스리프트
  - 두 가지 방식
    1. 바이너리 프로토콜 : 필드 이름 없음, 대신 **필드 태그** 존재
    2. 컴팩트 프로토콜 : 34 바이트 부호화. 가변 길이 정수 사용.
  ```
  struct Person {
    1 : required string       userName,
    2 : optional i64          favoriteNumber,
    3 : optional list<string> interests
  }
  ```
- 프로토콜 버퍼
  - 33 바이트
  ```
  message Person {
    required string user_name       = 1;
    optional int64 favorite_number  = 2;
    repeated string interests       = 3;
  }
  ```

#### 필드 태그와 스키마 발전
필드추가  
- 새로운 태그 번호 부여 -> 상위호환성 유지
- 추가 필드 optional or default 값 설정 -> 하위 호환성 유지 


필드 수정
- 필드명 수정 가능, 필드 태그 수정 불가


필드 삭제
- optional 필드만 삭제 가능
- 같은 태그 번호 재사용 불가

#### 데이터 타입과 스키마 발전
프로토콜 버퍼 : repeated 표시자  
스리프트 : 전용 목록 데이터 타입  


## 1.3 아브로(AVRO)
- 또 하나의 이진 부호화 형식  
- 스키마 사용. 두 개의 스키마 언어 존재(아브로 IDL, JSON 기반)  
- 스키마에 태그 번호 없음.
- 모든 부호화 중 길이가 가장 짧음
- 바이트열 내 필드, 데이터 타입 식별 위한 정보 없음.

아브로 IDL  
```
record Person {
  string                userName;
  union { null, long }  favoriteNumber = null;
  array<string>         interests;
}
```

JSON 표현  
```json
{
  "type": "record",
  "name": "Person",
  "fields": [
    {"name": "userName",        "type": "string"},
    {"name": "favoriteNumber",  "type": ["null", "long"], "default": null},
    {"name": "interests",       "type": {"type": "array", "items": "string"}}
  ]
}
```


# 2. 데이터플로 모드