---
layout: post
title: "[데이터 중심 애플리케이션 설계] 4장. 부호화와 발전"
subtitle: "데이터 중심 애플리케이션 설계, 4장, 부호화와 발전"
categories: various
tags: techBook
---
> 4장. 부호화와 발전

4장의 핵심 내용  
- 인코등 다양한 형식
- 메시지 전달 시스템과 데이터 인코딩 형식 -> 데이터 저장 및 통신에서의 사용 방법

**상위 호환성** : 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야.  
**하위 호환성** : 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야.  

# 1. 데이터 부호화 형식
**부호화**(직렬화) : 인메모리 표현 -> 바이트열  
**복호화**(파싱, 역직렬화) : 바이트열 -> 인메모리 표현  

## 1.1 언어별 형식
각 언어 별 직렬화 기능 내장되어 있음. 

- 언어 내장 부호화 라이브러리 문제점
  - 특정 언어와 강결합 : 다른 언어와의 통합 시 어려움 존재
  - 보안 : 바이트 복호화 시 보안 관련 문제 발생 가능성 존재
  - 상, 하위 호환성 떨어짐
  - 효율성 : 성능 떨어지는 경우 많음.


## 1.2 JSON, XML, 이진변형
### JSON
- 문자열, 수 구분.
- 정수, 부동소수점 수 구별 X, 정밀도 지정 불가
- 2^53 보다 큰 정수 부정확해질 가능성 존재
- 유니코드 문자열 지원. 이진 문자열 지원 X
- 스키마 지원

### XML
- 복잡한 형식
- 수, 숫자(digit) 문자열 구분 불가
- 유니코드 지원. 이진 문자열 지원 X.
- 스키마 지원

### CSV
- 수, 숫자(digit) 문자열 구분 불가
- 스키마 X
- 모호한 형식 : 값이 쉼표, 개행문자 포함 경우 난감;;


### 이진 부호화
JSON과 XML은 간단. 허나 공간에 있어 이진 형식보다 큼. 이진 부호화가 크기, 파싱 속도에 있어 효율적. but, 가독성과 크기 간의 트레이드 오프는 고민 지점.

#### 스리프트 & 프로토콜 버퍼
> 이진 부호화 라이브러리
> 스리프트, 프로토콜 버퍼 모두 스키마 필요.
> 기존 이진 부호화와 달리 `필드 태그` 존재
> 스키마의 required, optional 정보에 대한 부호화 X. 실행 때 확인

- 스리프트
  - 두 가지 방식
    1. 바이너리 프로토콜 : 필드 이름 없음, 대신 **필드 태그** 존재
    2. 컴팩트 프로토콜 : 34 바이트 부호화. 가변 길이 정수 사용.
  ```
  struct Person {
    1 : required string       userName,
    2 : optional i64          favoriteNumber,
    3 : optional list<string> interests
  }
  ```
- 프로토콜 버퍼
  - 33 바이트
  ```
  message Person {
    required string user_name       = 1;
    optional int64 favorite_number  = 2;
    repeated string interests       = 3;
  }
  ```

#### 필드 태그와 스키마 발전
필드추가  
- 새로운 태그 번호 부여 -> 상위호환성 유지
- 추가 필드 optional or default 값 설정 -> 하위 호환성 유지 


필드 수정
- 필드명 수정 가능, 필드 태그 수정 불가


필드 삭제
- optional 필드만 삭제 가능
- 같은 태그 번호 재사용 불가

#### 데이터 타입과 스키마 발전
프로토콜 버퍼 : repeated 표시자  
스리프트 : 전용 목록 데이터 타입  


## 1.3 아브로(AVRO)
- 또 하나의 이진 부호화 형식  
- 스키마 사용. 두 개의 스키마 언어 존재(아브로 IDL, JSON 기반)  
- 스키마에 태그 번호 없음.
- 모든 부호화 중 길이가 가장 짧음
- 바이트열 내 필드, 데이터 타입 식별 위한 정보 없음.

아브로 IDL  
```
record Person {
  string                userName;
  union { null, long }  favoriteNumber = null;
  array<string>         interests;
}
```

JSON 표현  
```json
{
  "type": "record",
  "name": "Person",
  "fields": [
    {"name": "userName",        "type": "string"},
    {"name": "favoriteNumber",  "type": ["null", "long"], "default": null},
    {"name": "interests",       "type": {"type": "array", "items": "string"}}
  ]
}
```

### 쓰기 스키마 & 읽기 스키마
***쓰기 스키마*** : 네트워크 전송. 파일, DB에 write. 스키마 버전 사용해 데이터를 아브로로 부호화할 때 사용 하는 스키마.  
***읽기 스키마*** : 네트워크 수신. 파일, DB read. 특정 스키마로 복호화할 때 사용 스키마.  

*아브로의 핵심 아이디어는 쓰기 스키마와 읽기 스키마가 동일하지 않아도 되며 단지 호환 가능하면 됨.*  
- 아브로 데이터 복호화 과정 : 쓰기 스키마, 읽기 스키마 모두 읽고, 쓰기 스키마에서 `읽기 스키마`로 데이터 변환.
- 필드 순서 상관 없음 : 필드명으로 매핑하기 때문
- 읽기 스키마 X & 쓰기 스키마 O : 해당 필드 무시
- 읽기 스키마 O & 쓰기 스키마 X : 읽기 스키마 디폴드 값 할당

### 스키마 발전 규칙
- 상위 호환성 : 새로운 버전의 쓰기 스키마와 예전 버전의 읽기 스키마
- 하위 호환성 : 새로운 버전 읽기 스키마와 예전 버전의 쓰기 스키마  


호환성 유지 위해 *기본 값이 있는 필드만 **추가**, **삭제** 가능*  
if1) 기본 값 없는 필드 추가 -> 새로운 읽기는 예전 쓰기 기록 데이터 읽기 불가. : 하위 호환성 X  
if2) 기본 값 없는 필드 삭제 -> 예전 읽기는 새로운 쓰기 데이터 읽기 불가 : 상위 호환성 X  

아브로의 경우 필드에 null을 허용하려면 `유니온 타입(union type)`을 사용. 프로토콜 버퍼, 스리프트의 optional, required 표시자 없음.-> union type, 기본 값으로 대체  

아브로는 타입 변경 가능. 필드 이름 변경 가능.  
이름 변경 시 필드 이름 별칭 통해 해결.



### 쓰기 스키마
읽을 때 쓰기 스키마 어떻게 확인?  
1. 많은 레코드가 있는 대용량 파일 : 파일 시작 부분에 한 번만 쓰기 스키마 포함
2. 개별적으로 기록된 레코드 소유 DB : 레코드 시작 부분 *스키마 버전* 정보 포함. DB에 별도 스키마 버전 관리.
3. 네트워크 연결을 통해 레코드 보내기 : 스키마 버전 합의


### 동적 스키마 : 아브로 장점
프로토콜 버퍼, 스리프트와 달리 **스키마에 태그 번호 미포함**. => 동적 생성 스키마에 더 친숙.  
필드는 이름으로 식별되어 아브로 스키마 생성 후 신경쓰지 않아도 됨.  

 
### 스키마 장점
프로토콜 버퍼, 스리프트, 아브로는 스키마 사용 이진 부호화 형식 기술.  
- XML 스키마, JSON 스키마보다 간단 + 더 자세한 유효성 검사 규칙 제공.
- 구현과 사용 더 간단. 광범위 프로그래밍 언어 지원

# 2. 데이터플로 모드
## 2.1 데이터베이스
## 2.2 서비스
## 2.3 메시지