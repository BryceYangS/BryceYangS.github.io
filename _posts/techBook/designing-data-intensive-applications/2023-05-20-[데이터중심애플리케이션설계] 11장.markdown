---
layout: post
title: "[데이터 중심 애플리케이션 설계] 11장. 스트림 처리"
subtitle: "데이터 중심 애플리케이션 설계, 11장, 스트림 처리"
categories: various
tags: techBook
---
> 11장. 스트림 처리

스트림 처리 : 매 초가 끝나는 시점에 1초 분량의 데이터 처리 or 고정된 시간 조각이라는 개념을 완전히 버리고 단순히 이벤트가 발생할 때마다 처리하는 방식  
스트림? 시간 흐름에 따라 점진적으로 생산된 데이터  

# 1. 이벤트 스트림 전송
**이벤트**
- 스트림처리 문맥에서의 레코드
- 특정 시점에 일어난 사건에 대한 세부 사항 포함
- 일반적으로 이벤트 발생 타임스탬프 포함
- 텍스트 문자열, JSON, 이진 형태 등으로 부호화
- 프로듀서가 만든 이벤트에 대해 여러 컨슈머가 처리 가능
  - 토픽이나 스트림으로 관련 이벤트를 묶음
- db에 데이터 저장 후 소비자가 지속적 폴링 방식은 오버헤드가 큼 -> 이벤트가 발생할 때마다 소비자에게 알리는 방식이 더 효율적

## 1.1 메시징 시스템
새로운 이벤트에 대해 소비자에게 알려주려고 쓰이는 일반적인 방식  
다수의 생산자 노드가 같은 토픽으로 메시지를 전송. 다수의 소비자 노드가 토픽 하나에서 메시지 수신.  

**발행/구독 모델**
메시징 시스템 구분한는 두 가지 질문  
1. 생산자가 소비자가 메시지를 처리하는 속도보다 빠르게 메시지 전송하는 경우
   1. 메시지 버리기
   2. 큐에 메시지 버퍼
   3. 배압
2. 노드가 죽거나 일시적으로 오프라인이 된다면 손실되는 메시지가 있을까?


### 생산자 -> 소비자 메시지 직접 전달
예시)
- UDP 멀티 캐스트 : 낮은 지연.
- ZeroMQ(브로커 X 메시지 라이브러리), nanomsg : TCP 또는 IP 멀티캐스트 상 발행/구독 메시징 구현
- StatsD, BruBeck : UDP 메시징 사용
- Webhook : 이벤트 발생할 때마다 콜백 URL 요청

메시지가 유실될 가능성 존재 ~> 애플리케이션 코드 작성 시 유의해야 함.  
직접 메시징 시스템은 일반적으로 생산자와 소비자가 항상 온라인 상태 가정 => 생산자 또는 소비자 오프라인 시 메시지 유실 가능성 존재

### 메시지 브로커
- 직접 메시징 시스템의 대안. `메시지 큐`라고도 함.  
- 생산자는 브로커로 메시지를 전송. 소비자는 브로커에서 메시지를 수신.  
- 지속성 문제 해결 : 데이터 저장을 브로커가 담당. 브로커의 클라이언트 상태 변경(접속, 접속 해제, 장애)에 쉽게 대처 가능
- 비동기 : 소비자는 생산자와 상관 없이 브로커의 큐 대기만 확인하고 소비하면 됨
  
### 메시지 브로커 vs 데이터 베이스
||메시지 브로커|DB|
|--|--|--|
|메시지 생애 주기|소비자 데이터 배달 성공 후 메시지 삭제|데이터 삭제 요청 때 삭제|
|큐 크기|작음||
|데이터 조회|특정 패턴과 부합하는 토픽의 부분 집합 구독|보조 색인 등 다양한 방법 존재|
|데이터 조회 결과|데이터 변경 시(새로운 메시지 생성) 클라이언트에 전달|질의 시점 스냅샷|

### 복수 소비자
주요 패턴 두 가지
1. 로드 밸런싱
   - 각 메시지는 소비자 중 **하나**로 전달
   - 브로커는 메시지를 전달할 소비자를 임의로 지정
   - 처리 병렬화 목적 소비자 추가하고 싶을 때 유용
2. 팬 아웃
   - 각 메시지는 **모든** 소비자에게 전달
   - 여러 독립적인 소비자가 브로드캐스팅된 동일한 메시지를 서로 간섭 없이 청취

두 가지 패턴 함께 사용 가능.  
eg) 두 개의 소비자 그룹에서 하나의 토픽을 구독하고 각 그룹은 모든 메시지를 받지만 그룹 내에서는 각 메시지를 하나의 노드만 받게 함.

### 확인 응답과 재전송
메시지 손실을 방지하기 위해 메시지 브로커는 **확인 응답** 사용.  
클라이언트는 메시지 처리가 끝았을 때 브로커가 메시지를 큐에서 제거할 수 있게 브로커에게 명시적으로 알려야 함.
- 만약 브로커 확인 응답 받기 전 클라이언트로의 연결 닫히거나 타임아웃 발생 시 : 브로커는 메시지 미처리 가정 -> 다른 소비자에게 재전송

로드 밸런싱 + 재전송 조합 : 메시지 순서에 영향
- 메시지1 전송 후 소비자 장애 발생.
- 메시지2 처리 후 재전송된 메시지1 소비 : 메시지2 -> 메시지1 순서로 이벤트 처리됨
- 해결 방안 : 소비자마다 독립된 큐 사용.(= 로드 밸런싱 미사용)

## 1.2 파티셔닝된 로그
브로커는 메시지를 일시적으로 보관하는 개념.  
브로커는 확인 응답을 받으면 메시지 삭제. 이미 받은 메시지는 복구 불가.  
데이터베이스의 지속성 있는 저장 방법 + 메시징 시스템의 지연 시간이 짧은 알림 기능 = `로그 기반 메시지 브로커`

### 로그를 사용한 메시지 저장소
생산자가 보낸 메시지는 로그 끝에 추가하고 소비자는 로그를 순차적으로 읽어 메시지 수신.  
**파티셔닝** : 처리량 높이기 위한 확장 방법으로 로그를 파티셔닝.  
**토픽** : 같은 형식의 메시지를 전달하는 파티션들의 그룹  
**오프셋** : 각 파티션 내 모든 메시지에 부여되는 단조 증가하는 순번

![Partition](/assets/img/techbook/designingdataintensive/11_partitioning.png)  

- 아파치 카프카, 아마존 키네시스 스트림, 트위터의 분산 로그 등

### 로그 방식 vs 전통적인 메시징 방식
- 로그 방식 : 처리량이 많고 메시지를 처리하는 속도가 빠르지만 메시지 순서가 중요
- JMS/AMQP 방식 : 메시지 처리 비용이 비쌈. 메시지 단위로 병렬화 처리. 메시지 순서 중요X

### 소비자 오프셋
- 소비자 오프셋 덕분에 브로커는 모든 개별 메시지마다 보내는 확인 응답 추적 불필요. 단지 주기적으로 소비자 오프셋 기록.  
- 소비자 노드 장애 발생 시 : 소비자 그룹 내 다른 노드에 해당 파티션 할당 -> 마지막 기록된 오프셋부터 메시지 처리
-  장애가 발생한 소비자가 처리, but 아직 오프셋 기록 못한 메시지 : 두 번 처리됨

### 디스크 공간 사용
**원형 버퍼(링 버퍼)**  
- 로그는 크기가 제한된 버퍼로 구현하고 버퍼가 가득 차면 오래된 메시지 순서대로 제거
- 메시지 보관 기관과 관계없이 모든 메시지를 디스크에 기록 => 로그 처리량 일정
  - cf) 메시징 시스템 : 메모리에 메시지 유지, 큐가 너무 커질 때만 디스크에 기록. 큐가 작을 때는 빠름. 디스크 기록 시작 시 매우 느려짐. 즉, 보유한 메시지 양에 따라 처리량 다름.

### 소비자가 생산자를 따라갈 수 없을 때
선택할 수 있는 세 가지 방안 : 버리기, 버퍼링, 배압  
로그 기반 방식은 버퍼링 형태.  
소비자가 뒤처져 필요한 메시지가 디스크에 보유한 메시지보다 오래되면 필요한 메시지 읽기 불가.  
- 특정 소비자가 너무 뒤처져도 다른 소비자에 영향 X

### 오래된 메시지 재생
AMQP/JMS 방식 메시지 브로커는 메시지 처리 확인 후 제거.  
로그 기반 메시지 브로커는 로그를 변화시키지 않는 읽기 전용 연산. 부수 효과는 소비자 오프셋 이동만 발생. 소비자 오프셋은 조작 가능.


# 2. 데이터베이스와 스트림
## 2.1 시스템 동기화 유지하기
## 2.2 변경 데이터 캡처
## 2.3 이벤트 소싱
## 2.4 상태와 스트림 그리고 불변성

# 3. 스트림 처리
## 3.1 스트림 처리의 사용
## 3.2 시간에 관한 추론
## 3.3 스트림 조인
## 3.4 내결함성

