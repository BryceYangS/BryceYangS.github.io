---
layout: post
title: "[데이터 중심 애플리케이션 설계] 6장. 파티셔닝"
subtitle: "데이터 중심 애플리케이션 설계, 6장, 파티셔닝"
categories: various
tags: techBook
---
> 6장. 파티셔닝

**6장의 핵심 내용**  
- 파티셔닝 방법
- 데이터 색인과 파티셔닝 상호작용
- 리밸런싱
- 라우팅

# 1. 파티셔닝과 복제
**파티셔닝** : 데이터셋이 매우 크거나 질의 처리량이 매우 높은 경우 데이터를 쪼개는 방식. *샤딩*이라고도 함.  
- 목적 : 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것
- 데이터 쏠린 경우 `skewed` 라고 함. 불균형하게 부하가 높은 파티션을 `핫스팟`이라고 함.
- 몽고 DB, 엘라스틱서치, 솔라클라우드의 **shard**에 해당

<br/>
보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장 => 내결함성 보장 가능.

# 2. 키-값 데이터 파티셔닝
어떤 레코드를 어느 노드에 저장할지 어떻게 결정?  
가장 단순한 방법은 레코드를 할당할 노드를 **무작위 선택** => 레코드가 어느 노드에 저장됐는지 알 수 없어 모든 노드에서 병렬적으로 질의 실행해야한다는 심각한 단점 존재.  
<br/>

***키-값 데이터 모델*** 사용. 항상 기본키를 통해 레코드에 접근.

## 1) 키 범위 기준 파티셔닝
> 각 파티션에 연속된 범위의 키를 할당하는 것.  

- 키 범위가 반드시 동일할 필요 없음 : 데이터 고른 분산을 위해 조정 가능.
- 파티션 경계는 관리자가 수동/자동 선택 가능.
- 각 파티션 내 키를 정렬된 순서로 저장 가능.
- 장점
  - 범위 스캔 용이
  - 키를 연쇄된 색인으로 간주해 질의 하나로 관련 레코드 여러개 읽어오는 데 사용 가능
- 단점
  - 특정한 접근 패턴이 핫스팟을 유발
    - eg) 타임스탬프가 키인 경우 해당 날짜에 대한 파티션에만 과부하
    - 이 문제를 해결하려면 키의 첫 번째 요소로 타임스탬프가 아닌 다른 것 사용해야. (eg. 앞에 다른 이름을 붙임)

## 2) 키의 해시 값 기준 파티셔닝
> 해시 함수 사용  

- 데이터를 입력으로 받아 해시 함수로 균일하게 분산되도록 함.
- 파티셔닝용 해시 함수는 암호적으로 강력할 필요 없음
  - 다만, 자바의 Object.hasCode()와 같이 동일 값에 대해 다른 해시 값을 반환하는 내장 해시 함수의 경우 부적합
- 각 파티션에 해시값 범위 할당 후 해시값이 파티션의 범위에 속하는 모든 키를 그 파티션에 할당
- 장점
  - 균일한 분산
- 단점
  - 범위 질의 비효율 : 키 범위 방식의 경우 인접했던 키들이 해시 값 기준 방식으로 인해 모든 파티션에 흩어져 정렬 순서 유지 불가
    - 몽고DB : 모든 파티션에 범위 질의
    - 카산드라 : 두 가지 파티셔닝 전략 타협. **복합 기본키** (키의 첫 부분 해싱 적용 + 남은 칼럼 정렬 색인 사용)

## 쏠린 작업부하 & 핫스팟 완화 트레이드오프
키를 해싱해도 핫스팟 완벽 제거 불가. (eg. 항상 동일한 키를 읽고 쓰는 극단적인 상황에서는 모든 요청이 동일 파티션에 집중)  
현대 데이터 시스템에서는 쏠림 자동 보정 불가 -> *애플리케이션*에서 쏠림을 완화해야 함.  
간단한 해결책은 <u>각 키의 시작이나 끝에 임의의 숫자를 붙이는 것</u>  
- 요청이 몰리는 소수의 키에만 적용하는 것이 합당 : 처리를 위한 추가 작업이 필요하기 때문 + 쓰기 처리량이 적은 대다수의 키에도 적용할 시 오버헤드 발생  

이러한 트레이드오프를 고려할 필요 있음.

# 3. 파티셔닝과 보조 색인
T.B.D.
# 4. 파티션 재균형화

# 5. 요청 라우팅
