---
layout: post
title: "[마이크로서비스패턴] 4장 트랜잭션 관리: 사가"
subtitle: "마이크로서비스패턴, 트랜잭션 관리, 사가 패턴"
categories: various
tags: techBook
---
> 4장. 트랜잭션 관리 : 사가 패턴

4장 핵심내용  
- 분산 트랜잭션이 적잘하지 않은 이유
- 사가 패턴 통한 데이터 일관성 유지
- 사가 : 코레오그래피/오케스트레이션 방식
- 비격리 문제 조치 대첵

# 마이크로서비스 아키텍처에서의 트랜잭션 관리
서비스마다 DB가 따로 있기 때문에 여러 DB에 걸쳐 데이터 일관성 유지위한 수단 필요.  

## 분산 트랜잭션
과거 분산 트랜잭션 활용해 데이터 일관성 유지([X/Open XA](https://ko.wikipedia.org/wiki/X/Open_XA): 분산 트랜잭션의 사실상 표준)  

### 단점
- NoSQL DB, 현대 메시지 브로커(RabbitMQ, 아파치 카프카) 등 미지원
- 동기 IPC : 가용성 떨어짐
- 요즘 애플리케이션에 부적합 : 일관성보다 가용성이 중시.

### 장점
- 로컬 트랜잭션과 프로그래밍 모델과 동일

## 사가
> 사가는 비동기 메시징을 이용해 편성한 일련의 로컬 트랜잭션. 서비스 간 데이터 일관성은 사가로 유지  

1. ACID 트랜잭션에서 *I(격리성)이 사가에는 없음*.
2. 로컬 트랜잭션마다 변경분을 커밋하므로 `보상 트랜잭션`을 걸어 롤백  


로컬 트랜잭션이 완료되면 **메시지**를 발행 -> 다음 사가 단계 트리거

### 보상 트랜잭션
사가는 트랜잭션이 진행하는 반대 방향으로 보상 트랜잭션을 실행

# 사가 편성
사가의 두 가지 종류 : choreography, orchestration  

## 코레오그래피 사가
의사 결정과 순서화를 **사가 참여자**에게 맡김. 사가 참여자는 주로 `이벤트` 교환 방식으로 통신  
중앙 편성자 부재. 대신 사가 참여자가 서로 이벤트 구독 통해 그에 따라 반응  

### 사가 참여자 간 발행/구독 방식 문제점
- 사가 참여자가 자신의 DB를 업데이트하고, DB 트랜잭션의 일부로 이벤트를 발행하도록 해야 함 : `트랜잭셔널 메시징`
- 사가 참여자는 자신이 수신한 이벤트와 자신이 가진 데이터를 연관 지을 수 있어야.
  - 상관관계 ID가 포함된 이벤트 발행 필요

### 장단점
#### 장점
- 단순 : 비즈니시 객체 생성, 수정, 삭제할 때 서비스가 이벤트 발행
- 느슨한 결합 : 참여자는 이벤트를 구독. 직접 알진 X

#### 단점
- 이해하기 어려움 : 여러 서비스에 구현 로직 산재.
- 서비스 간 순환 의존성 : 이벤트로 인한 순한 의존 가능성
- 단단히 결합 위험성


===> 간단한 사가의 경우 코레오그래피 방식도 충분. but, 복잡한 사가는 오케스트레이션이 적합

## 오케스트레이션 사가
사가 편성 로직을 `사가 오케스트레이터`에 중앙화. 사가 오케스트레이터는 사가 참여자에게 **커맨드** 메시지를 보내 수행 작업 지시  
사가 오케스트레이터는 커맨드/비동기 응답 상호 작용통해 참여자와 통신  

*커맨드 메시지 전송 -> 사가 참여자 작업 수행 & 응답 -> 오케스트레이터 응답 처리 -> 다음 사가 단계 참여자에게 커맨드 -> ...*  

### 사가 오케스트레이터를 상태 기계로 모델링
상태 기계?
- 구성 : 상태 & 상태 전이
- 사가 참여자가 로컬 트랜잭션 완료 시점 트리거됨 -> 로컬 트랜잭션 상태, 결과 기준 차후 상태 전이 및 액션 결정
- 설계, 구현, 테스트 용이

### 장단점
#### 장점
- 의존 관계 단순화 : 순환 의존성 발생 X
- 낮은 결합도
- 관심사를 더 분리하, 비즈니스 로직 단순화

#### 단점
- 과도한 책임의 오케스트레이터
  - 오케스트레이터는 순서화만 담당. 비즈니스 로직 미포함하도록 설계 통해 해결

# 비격리 문제 처리
T.B.D(171p~)


# 주문 서비스 및 주문 생성 사가 설계