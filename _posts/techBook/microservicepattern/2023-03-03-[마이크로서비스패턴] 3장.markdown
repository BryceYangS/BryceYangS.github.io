---
layout: post
title: "[마이크로서비스패턴] 3장 프로세스 간 통신"
subtitle: "마이크로서비스패턴, 프로세스 간 통신"
categories: various
tags: techBook
---
> 3장. 프로세스 간 통신

3장 핵심내용
- 다양한 통신 패턴
- 마이크로서비스 아키텍처에서 IPC 중요성
- API 정의 및 발전
- 여러 가지 IPC와 각각의 트레이드오프
- 비동기 메시징 통신 장점
- 메시지를 DB 트랜잭션에 태워 확실하게 전송


*IPC(Inter-Process Communication, 프로세스 간 통신)*


# 3.1 마이크로서비스 아키텍처 IPC 개요
## 상호작용 스타일
두 가지 기준  

1. 일대일/일대다
    - 일대일
        - 요청/응답 : 응답을 기다리기 때문에 강결합 스타일
        - 비동기 요청/응답
        - 단방향 알림
    - 일대다
        - 발행/구독
        - 발행/비동기 응답
2. 동기/비동기


마이크로서비스에서 API 클라이언트와 서버는 함께 컴파일 되지 않음. 즉, 기존 API와 호환되지 않는 새 버전의 API가 배포되면 컴파일 에러 없이, 런타임 시 에러 발생.  

## API 변경 방법
### 시맨틱 버저닝
- MAJOR.MINOR.PATCH 세파트로 구성
    - MAJOR : 하휘 호환되지 않는 변경분 API 적용 시
    - MINOR : 하휘 호환되는 변경분 API 적용 시
    - PATCH : 하휘 호환되는 오류 수정 시
### 하휘 호환되는 소규모 변경
- 견고성 원칙 : 요청 속성 누락 시 기본값 제공. 필요한 것보다 더 많은 속성 응답 시 클라이언트는 무시.
### 중대한 대규모 변경
- 신구 버전 API 모두 지원
    - url 경로에 v1, v2 등의 메이저 번호 기입
    - MIME 타입 내부에 버전 번호 삽입

## 메시지 포맷
### 텍스트
- JSON, XML 등
- 장점
    - 사람이 읽을 수 있음
    - 하휘 호환성 쉽게 보장 : 관심 있는 값만 골라쓰면 됨
    - 문서화 용이 : XML 스키마, JSON 스키마
- 단점
    - 메시지가 김 : 속성 + 속성명 -> 파싱 오버헤드 가능성 존재

### 이진 
- 프로토콜 버퍼, 아브로
- 장점
    - 효율/성능이 우수함
- [Avro vs Protocol Buffers vs Thrift 비교](https://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html)
    - Avro 컨슈머는 스키마를 알고 있어야 메시지 해석 가능

# 3.2 동기 RPI 패턴 응용 통신
*RPI(Remote Procedure Invocation, 원격 프로시저 호출)*  
- 클라이언트가 서비스에 요청. 서비스가 처리 후 응답 회신하는 IPC

## 동기 RPI 패턴 : REST
HTTP 사용 IPC  
- 리소스에 대한 행위를 HTTP method로 표현  

### REST 성숙도 모델
- 레벨 0 : 유일한 end point에 POST 요청. 액션 + 대상 + 매개변수
- 레벨 1 : 리소스 개념 지원. 액션 + 매개변수 POST요청.
- 레벨 2 : HTTP 동사 이용.
- 레벨 3 : HATEOAS 원칙 기반 설계.


### REST 장단점
#### 장점
- 단순, 익숙
- postman, curl 등 통해 테스트 쉬움
- 요청/응답 스타일 통신 직접 지원
- 방화벽 친화적 : 단일 포트 사용, 인터넷에서 서버 접속 가능, TCP 사용
- 시스템 아키텍처 단순 : 중간 브로커 불필요
#### 단점 
- 요청/응답 통신만 지워
- 가용성 떨어짐 : 서버/클라이언트 모두 실행중이어야
- 서비스 인스턴스 위치를 클라이언트가 알고 있어야 : 서비스 디스커버리 매커니즘 활용
- 요청 한 번으로 여러 리소스 조회 어려움 : GraphQL, Netflix Falcor 등 통해 해결하고자
- HTTP 동사 매핑 어려움 경우 존재 : 다중 업데이트 작업 등

## 동기 RPI 패턴 : gRPC
- 다양한 언어로 클라이언트/서버 작성 가능한 프레임워크  
- **`이진 메시지`** 기반 프로토콜
- 프로토콜 버퍼 기반의 IDL로 정의
- 프로토콜 버퍼 컴파일러 : 클라이언트 쪽 스텁 / 서버 쪽 스켈레톤 생성.
    - 다양한 언어 코드 생성 가능
- **HTTP/2** 통해 교환
- 스트리밍 RPC도 지워
- 프로토콜 버퍼 메시지 포맷 사용

### gRCP 장단점
#### 장점
- 다양한 업데이트 작업 API 설계 용이
- 큰 메시지 교환 시 콤패트, 효율적
- 양방향 스트리밍 -> RPI, 메시징 두 가지 통신 방식 모두 가능
- 다양한 언어 연동 가능

#### 단점
- 자바스크립트 클라이언트가 하는 일이 REST/JSON 기반 API보다 많음
- 구형 방화벽 HTTP/2 미지원

## 부분 실패처리 : 회로 차단기 패턴
[circuit-breaker](https://microservices.io/patterns/reliability/circuit-breaker.html)  
*circuit breaker : 연속 실패 횟수가 임계치 초과 시 일정 시간 동안 호출 즉시 거부 RPI 프로시*  

### 견고한 RPI 프록시 설계
- 네트워크 타임아웃
- 미처리 요청 개수 제한
- 회로 차단기 패턴s

### 불능 서비스 복구
무응답 원격 서비스에 대한 복구는 상황에 맞게 조치. 중요하지 않은 데이터라면 캐시 활용 또는 에러, 데이터 자체를 제외하는 등의 방법이 있을 것.

## 서비스 디스커버리
클라우드 환경 마이크로서비스는 네트워크 위치가 동적 할당. 오토 스케일링, 실패, 업그레이드 등으로 네트워크는 계속해서 변화. => **서비스 디스커버리** 필요성 대두  

*서비스 디스커버리 : 애플리케이션 서비스 인스턴스의 네트워크 위치를 DB화한 서비스 레지스트리*  
- 클라이언트/서비스가 직접 서비스 레지스트리와 상호 작용
- 배포 인프라로 서비스 디스커버리 처리

### 디스커버리 두 가지 요소
> Netflix Eureka, Eureka java client, Ribbon(유레카 클라이언트 지원 HTTP 클라이언트) => Spring Cloud  

#### 1) 자가 등록 패턴
- [self-registration](https://microservices.io/patterns/self-registration.html)
- *서비스 인스턴스는 서비스 레지스트리에 자기 자신을 등록*
- 서버 : 서비스 레지스트리 등록 API 호출 + 헬스 체크 제공

#### 2) 디스커버리 패턴
- *서비스 클라이언트는 서비스 레지스트리에 있는 가용 서비스 인스턴스 목록을 조회하고 부하 분산* [참고](https://microservices.io/patterns/client-side-discovery.html)

### 플랫폼 내장 서비스 디스커버리 패턴 적용
Docker, k8s 서비스 레지스트리, 서비스 디스커버리 메커니즘 탑재(k8s 의 `service` 오브젝트)  

#### 1) 서드파티 등록 패턴
- *서드파티가 서비스 인스턴스를 서비스 레지스트리에 자동 등록*
- 배포 플랫폼의 등록기라는 서드 파티가 서비스 레지스트리에 등록하는 작업 수행
#### 2) 서버 쪽 디스커버리 패턴
- *클라이언트가 서비스 디스커버리를 담당한 라우터에 요청*
- 클라이언트는 DNS명을 요청  


플랫폼에 제한적이라는 단점. 하위 블로그 글 참조.  
[Spring Cloud vs Kubernetes](https://bryceyangs.github.io/study/2021/07/28/MSA-SpringCloud-vs-Kubernetes/)


# 3.3 비동기 메시징 패턴 응용 통신
T.B.D
# 3.4 비동기 메시징으로 가용성 개선
# 3.5 마치며

# 참조
- [https://microservices.io/patterns/index.html](https://microservices.io/patterns/index.html)